\documentclass[10pt, english]{article}
\usepackage[]{graphicx}
\usepackage[]{color}
\usepackage{alltt}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\setlength{\parskip}{\smallskipamount}
\usepackage{lipsum}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{mathabx}
\usepackage{tikz}
\usepackage[noend]{algpseudocode}
\usepackage[section]{algorithm}
\usepackage{algorithmicx}
\usepackage{xspace}
\usepackage{fancyvrb}
\usepackage[titletoc]{appendix}
\usepackage{url}


\begin{document}

\newcommand{\var}{\mathrm{var}}
\newcommand{\val}{\mathrm{val}}

\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

	\clearpage\thispagestyle{empty}
	\centering
	\vspace{1cm}

	\textsc{\Large Specification}\\[.5cm]
	\HRule\\[.5cm]
	{\Huge Zero Knowledge circuit \par}
	\vspace{.5cm}
	{\Large for continuation-passing interpreter \par}
	\vspace{.5cm}
	\HRule \\[.5cm]


\includegraphics[width=0.4\textwidth,scale=1]{logo.png}\\[.1cm]
	{\large \today}\\[2cm]
\vfill
\end{titlepage}


\begin{abstract}
  \end{abstract}

\tableofcontents

\newpage

\section{Introduction}

In this document we describe the implementation of a \emph{Continuation Passing Style} (CPS) interpreter for a language called Lurk, which was designed specifically for Zero Knowledge Proof (ZKP) systems.

We are going to closely follow the approach proposed in the book ``Essentials of Programming Languages''~\cite{FWbook}.

\section{Zero Knowledge Proofs}

In this section we present some basic concepts that are required in order to understand this specification.

\subsection{Basic concepts}

The zero knowledge Apia

\begin{itemize}
		\item[-] \textbf{Setup.}
		\item[-] \textbf{Prove.}
		\item[-] \textbf{Verify.}
\end{itemize}

SNARKs

The trusted setup problem.

The witness and its relation to non-deterministic memory.

Circuits, R1CS and other formats.

\subsection{Backends}

Groth16~\cite{groth16}

Nova~\cite{nova}

Halo2~\cite{halo, halo2}


\section{Lurk}

In this section we shortly describe Lurk concepts.

\subsection{Overview}

We construct an interpreter for a functional language called Lurk.

It is a Turing-complete language.

The interpreter is based on CPS.

We have an environment where we can manage variable bindings. For instance, the environment can be represented by the following list:

$$\{(\var_{0}, \val_{0}), \dots, (\var_{n}, \val_{n})\}.$$



We have expressions that can represent recursive data and operations.

We have continuations, which can be used to manage control flow of programs.






\subsection{Examples}


\subsubsection{Exponentiation}

\begin{verbatim}
(letrec ((exp (lambda (base exponent)
                 (if (= 0 exponent)
                     1
                     (* base (exp base (- exponent 1)))))))
         (current-env))
\end{verbatim}


\subsubsection{Fibonacci}

\begin{verbatim}
(letrec ((next (lambda (a b n target)
                 (if (eq n target)
                     a
                     (next b
                           (+ a b)
                           (+ 1 n)
                           target))))
         (fib (next 0 1 0)))
        (current-env))
\end{verbatim}

\subsection{Components}

\subsubsection{t, nil}

\subsubsection{if}

\subsubsection{lambda}

\subsubsection{let}

\subsubsection{letrec}

\subsubsection{quote}

\subsubsection{atom}

\subsubsection{cons, car, cdr}

\subsubsection{Arithmetic operations}

\subsubsection{Equality test}

\subsubsection{Current env}


\subsection{Expressions}

\subsection{Environment}

\subsection{Continuation}

\subsection{Store}

\section{Circuit}

\subsection{Overview}

\subsection{Gadgets}

\subsubsection{Macros}

Boolean

Equality

Pick

\subsubsection{Constraints}

Arithmetic operations

Utils

\subsubsection{Pointer}

Tag

Hash

\subsubsection{Data}

allocate

reverse lookup

\subsubsection{Multicase}

case

multicase

optimization


\section{Final remarks}

\section{References}

\bibliographystyle{plain}

\bibliography{refs}

\end{document}
